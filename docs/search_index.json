[
["manip.html", "3 Manipular 3.1 select 3.2 filter 3.3 mutate 3.4 arrange 3.5 summarise 3.6 Dataset “can_phoma”", " 3 Manipular Muchas veces los datos que importamos ya están listos para ser explorados y analizados. Otras veces precisan ser manipulados previamente para ello. En estos casos se parte de un dataset “crudo” y se transforma hacia un dataset “analítico”. Recordando que un dataset debe ser completo con dimensiones n_fila x n_columna, donde: 1- Cada fila debe contener toda la info de la unidad experimental que se está evaluando 2- Cada columna representa una variable (descriptiva o respuesta) 3- Cada celda debe tener su observación (en caso de faltar el dato será un NA) tidyr y dplyr integran parte de la colección de paquetes de tidyverse y facilitan la manipulación de los data frames (Wickham and Grolemund 2016) library(tidyverse) Ambos paquetes utilizan el operador %&gt;% (pipe, tubo en español) lo que proporcionan una mejor interpretación lógica: utiliza el resultado de su lado izquierdo como primer argumento de la función del lado derecho (asemejándose a una receta de torta…) x &lt;- c(1, 2, 3, 4) x %&gt;% sum %&gt;% sqrt Su equivalente de código básico es: sqrt(sum(x)) Importemos los datos “soja” para ver alguno ejemplos. Red de ensayos de fungicidas para el control de mancha anillada en soja soy &lt;- readr::read_csv(&quot;data/soja_mancha.csv&quot;) soy # browseURL(&quot;https://osf.io/jpfet/&quot;) study: identificador arbitrario para cada experimento year: año del experimento location: localidad do experimento cultivar: cultivar de soja utilizado fungic: tratamiento fungicida block: repeticiones sev: severidad (%) evaluada en R6 yield: rendimiento en madurez fisiológica (kg/ha) Los cinco verbos (funciones) principales de dplyr son: select filter mutate arrange summarise Primero vamos a explorar el dataset que acabamos de importar: summary(soy) str(soy) Haremos que las variables tipo caracter sean convertidas a factores: soy$cultivar &lt;- as.factor(soy$cultivar) soy$fungic &lt;- as.factor(soy$fungic) soy$Yld_level &lt;- as.factor(soy$Yld_level) soy$YR_class &lt;- as.factor(soy$YR_class) soy$gr_hab &lt;- as.factor(soy$gr_hab) summary(soy) str(soy) 3.1 select Vamos a seleccionar las variables: study, year, cultivar, fungic, rep, sev y yield. soy %&gt;% select(study, year, cultivar, fungic, rep, sev, yield) Es posible usar intervalos de varibles con :. Una selección “negativa” de las variables no deseadas daría un mismo resultado: soy %&gt;% select(-Yld_level, -YR_class, -gr_hab, -sev_check) 3.2 filter Semejante a subset. Condiciones separadas por comas equivalen a &amp; de subset. Filtremos la variable fungicida (fungic) por el testigo (ZZ_CHECK) soy %&gt;% select(study:yield) %&gt;% filter(fungic == &#39;ZZ_CHECK&#39;) Ahora, agreguemos el fungicida carbendazim a dosis de 1 litro (CZM[1]) al dataset soy %&gt;% select(study:yield) %&gt;% filter(fungic %in% c(&quot;ZZ_CHECK&quot;,&quot;CZM&quot;)) 3.3 mutate Creación de nuevas variables (a partir de las existentes) Muchas variables biológicas no cumplen con los supuestos de las pruebas estadísticas paramétricas: no se distribuyen normalmente, las desviaciones estándar no son homogéneas, o ambas. Hay extensa bibliografia al respecto, recomendando cual transformación es la más adecuada para cada tipo de variable y asi poder ser analizada por un ANOVA tradicional (paramétrico). Como fitopatólogos, la no normalidad es lo predominante. El caso mas común es la severidad de enfermedades que comparamos a través de diferentes tratamientos (cultivar, fungicida, practica de manejo, etc.) Dos transformaciones son mayormente sugeridas para la severidad: Transformacion Arcsine:consiste en tomar el arcoseno de la raiz cuadrada de un numero. Transformación logit: soy1 &lt;- soy %&gt;% select(study:yield) %&gt;% filter(fungic %in% c(&quot;ZZ_CHECK&quot;,&quot;CZM&quot;)) %&gt;% mutate(sev_arc = asin(sqrt(sev/100)), sev_logit = car::logit(sev, percents=TRUE),# log(sev/100/(1-sev/100)), # yield_tn = yield/1000) # browseURL(&quot;http://strata.uga.edu/8370/rtips/proportions.html&quot;) soy &lt;- readr::read_csv(&quot;data/soja_mancha.csv&quot;) soy &lt;- soy %&gt;% mutate_if(is.character, as.factor) 3.4 arrange Ordena crecientemente de acuerdo a la columna que le indiquemos. Utilizar “desc”&quot; para orden decreciente. soy1 %&gt;% arrange(year, cultivar) soy1 %&gt;% arrange(year, desc(cultivar)) 3.5 summarise Generalmente acompañada de la función group_by la cual permite aplicar un cálculo a las observaciones agrupando por niveles de algún factor (equivale a una tabla dinámica de excel) Veamos cuanto fue el rendimiento promedio y el desvio standard para cada fungicida a través de todos los ensayos: soy %&gt;% group_by(fungic) %&gt;% summarise(yield_mean = mean(yield), yield_sd = sd(yield)) Calculen el rendimiento mínimo y máximo por fungicida Algunas funciones interesantes para la descripción del dataset: n(), n_distinct(). Cuantos ensayos fueron realizados por año: soy %&gt;% group_by(year) %&gt;% summarize(n = n_distinct(study)) Cuantas parcelas tenia cada ensayo: soy %&gt;% group_by(study, year, cultivar) %&gt;% summarize(plots = n()) Adicione una columna de potencial de rendimento del ensayo (rend_pot), considerando el máximo rendimiento observado en ese ensayo. Usando la función ifelse cree una nueva variable categórica “presión de enfermedad” considerando a “sev_check”: Low ou High by_check = soy %&gt;% filter(fungic==&quot;CHECK&quot;) %&gt;% group_by(study) %&gt;% summarize(sev_check = round(mean(sev, na.rm = TRUE),1)) %&gt;% mutate(Dis_level = ifelse(sev_check &lt; 30, &quot;Low&quot;, &quot;High&quot;)) Funciones auxiliares join junta dos data.frames a través de puntos em común. Por ejemplo, si queremos anexar las variables “sev_check” e “Dis_level” al dataset soy: soy %&gt;% full_join(by_check, by=&quot;study&quot;) 3.6 Dataset “can_phoma” can_phoma Esto seria uma forma “wide” de representación del dataset (crudo). Para analizar el efecto del tratemiento fungicida necesitamos calcular el área bajo la curva (AUC) del progreso de la enfermedad. Para esto vamos a transponer can_phoma al formato “long”. La función gather (del inglés “reunir”, pacote tidyr) apila las columnas que indiquemos. # crearemos una variable &quot;tt&quot; con los nombres de las columnas con números, # y otra &quot;incp&quot; (incidencia en proporción) con los valores correspondientes. can_long &lt;- can_phoma %&gt;% gather(`015`, `058`, `095`, `146`, `165`, `180`, `248`, key = &quot;tt&quot;, value = &quot;incp&quot;) # gather(tt, incp, -c(par:bk)) ;) #save(can_phoma, can_long, file = &quot;canolass.RData&quot;) can_long # Precisamos que tt sea clase &quot;numerica&quot; para certos cálculos can_long$tt &lt;- as.numeric(can_long$tt) Calcularemos un valor de AUC por parcela con auxilio de las funciones group_by y summarize auc &lt;- can_long %&gt;% group_by(trt, bk) %&gt;% summarize(AUC = agricolae::audpc(incp, tt)) Ahora si, can_phoma está listo para entrar al próximo paso: modelado. References "]
]
